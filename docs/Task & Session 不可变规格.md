很好。
你已经把**所有会导致系统“方向性分叉”的问题全部拍板**了。
下面这份就是你要的那一页——**不可变规格（Immutable Spec）**。
它不是 PRD，也不是架构设计，而是**所有后续 AI / 工程 / Agent 都必须服从的宪法级约束**。

---

# Task & Session 不可变规格（Immutable Spec · v1）

> 本文档定义系统中 **Task（任务）** 与 **Session（会话）** 的第一性原则。
> 一旦确立，除非系统整体重构，否则不得随意更改。

---

## 1. 核心设计哲学（Design Philosophy）

1. **行动优先于完美理解**
2. **失败是正常、可讨论、可复盘的产物**
3. **人类拥有最终主权，但不是持续参与者**
4. **Agent 是可替换、可回滚的执行单元，而非系统本体**
5. **Session 是稳定的协作关系载体，而非一次性对话**

---

## 2. Task（任务）不可变规则

### 2.1 Task 定义

* **任何 ≥10 分钟的任务，均视为长任务**
* 不存在“中等任务”模型
* 短任务仅指：

  * 即时执行
  * 不进入长期状态管理
  * 不产生长期上下文依赖

---

### 2.2 Task 生命周期（核心规则）

* Task 是 **状态可变实体**
* 允许在执行过程中：

  * 自动升级为复杂任务
* 升级规则：

  1. **立即暂停当前执行**
  2. **通知用户**
  3. **等待用户确认后继续**

> ⚠️ 不允许在用户不知情的情况下隐式升级

---

### 2.3 澄清机制（Clarification）

* 每个 Task 存在 **澄清预算**

  * 默认：30 次（可配置）
* 澄清预算耗尽后的终态：

  * **强制假设**
  * **标记为「高风险执行」**
  * **继续执行任务，不阻塞系统**

> 系统不得因为“理解不充分”而拒绝行动

---

### 2.4 高风险执行与失败

* 高风险执行失败：

  * **仅对当事人可见**
  * 不进入全局广播
* 失败必须：

  * 可记录
  * 可复盘
  * 可用于后续技能沉淀

---

### 2.5 Task 终结权

* **所有 Task / Project 只能由人类终结**
* Agent：

  * 不得自行关闭项目
  * 不得自行宣布“项目完成”

---

## 3. Session（会话）不可变规则

### 3.1 Session 定义

* Session 是：

  * 一次 **持续的工作关系**
  * 一个 **稳定的上下文容器**
* Session 可承载：

  * 单聊
  * 群聊
  * 项目协作

---

### 3.2 工具即联系人（Tool-as-Contact）

* 每一个工具 / Agent：

  * 在社交 App 中表现为一个“联系人”
* 工具身份：

  * **稳定**
  * 不随版本更新而改变

---

### 3.3 Session 并行规则

* 同一个工具联系人：

  * **允许并行多个 Session**
* 每个 Session：

  * 上下文独立
  * 历史独立
  * 状态独立

---

### 3.4 能力变化标记（Critical）

* 当 Agent 的 Prompt / Skill 发生变化：

  * **必须在 Session 中留下能力变化标记**
* 标记用于：

  * 人类理解历史上下文
  * 后续复盘与责任划分

> 世界不会回滚，但变化必须被看见

---

## 4. Agent 不可变规则

### 4.1 Agent 定位

* Agent 是：

  * 执行者
  * 建议者
  * 协作者
* Agent **不是**：

  * 系统主控
  * 最终裁决者
  * 项目所有者

---

### 4.2 Agent 学习机制

* Agent 本体 Prompt：

  * 修改是**严肃行为**
  * 不频繁自动变更
* 系统“可学习性”来源于：

  * Skill 沉淀
  * Skill 迭代
  * 策略层优化
* Prompt 回滚粒度：

  * **仅限 Prompt / Skill**
  * 不回滚世界状态与历史

---

## 5. 定时任务（Scheduled Task）不可变规则

* 定时任务连续失败达到阈值（默认 5 次，可配置）：

  1. 自动暂停
  2. 私聊用户
  3. 强提醒（非群广播）

> 系统宁可停机，也不允许长期无效运行

---

## 6. 主动行为（Proactivity）不可变规则

* 主动行为允许被用户：

  * 赞 / 踩
* 反馈策略：

  * 不即时生效
  * 以 **半个月为周期** 汇总分析
* 系统必须：

  * 向用户展示分析结果
  * 与用户共同优化策略 / Prompt

---

## 7. 不可违反铁律（Hard Constraints）

1. Agent 不得绕过人类终结项目
2. Task 不得在用户不知情下升级
3. 澄清失败不得阻塞执行
4. 能力变化不得隐形发生
5. Session 历史不得被篡改
6. 系统不得假装“从未失败”

---

### 📌 结语（这一页的意义）

> 这不是“怎么做 Agent”，
> 而是 **人类如何与 Agent 共事的契约**。

从这一刻开始：

* 架构
* 数据模型
* API
* Agent 设计
* Prompt 设计

都只能是 **这份规格的实现方式**，而不是挑战者。

---

如果你愿意，下一步我建议三选一（都是**架构级推进**）：

1️⃣ 把这份规格 **映射成 Core Domain（Task / Session / Project / Agent）**
2️⃣ 基于它，设计 **最小可运行 Kernel（无 Agent 版本）**
3️⃣ 做一次 **v1 复杂度削减审计（砍掉 20–30%）**

你现在已经站在「**可以开始写系统，而不是试验想法**」的位置上了。
